<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Whale - Jekyll</title>
    <description></description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 16 Jan 2023 18:27:01 +0900</pubDate>
    <lastBuildDate>Mon, 16 Jan 2023 18:27:01 +0900</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>STL!!</title>
        <description>&lt;h2 id=&quot;sequence-containers&quot;&gt;Sequence Containers&lt;/h2&gt;
&lt;p&gt;데이터를 순차적으로 저장하는 자료 구조입니다. 구현이 단순하고 가벼우며 빠릅니다. 대표적으로 Vector(Arrray), Deque, List가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;vectorarray&quot;&gt;Vector(Array)&lt;/h3&gt;
&lt;p&gt;메모리 상에서 데이터가 연속적으로 위치하는 배열입니다. 지금까지 흔하게 사용했던 배열들과 유사하지만 배열의 크기를 알 수 있고 변하지 않는다면 array를 동적인 크기를 원한다면 vector를 선택하면 됩니다. std::vector는 포인터 세 개로 구현이 되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;할당된 배열의 시작 주소를 가리키는 포인터&lt;/li&gt;
  &lt;li&gt;다음 데이터가 삽입될 위치를 가리키는 포인터&lt;/li&gt;
  &lt;li&gt;배열의 끝 주소를 가리키는 포인터&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/Vector.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;deque&quot;&gt;Deque&lt;/h3&gt;
&lt;p&gt;저장 공간의 앞, 뒤에 데이터를 빠르게 넣고 뺄 수 있는 Double-Ended QUEue(DEQUE)입니다. deque는 여러개의 버퍼에 데이터를 나눠서 저장합니다. Deque는 Vector에 비해서 앞뒤로 삽입 및 삭제가 빨라 유리해 보이지만 차이가 있습니다. Vector는 요소들이 메모리에 연속적으로 존재하는 것이 보장되지만, Deque는 요소들이 연속적인 것이 보장되지 않습니다. 따라서 배열과 관련된 라이브러리를 사용해야 할 때나 공간지역성을 고려해야 하는 상황에서는 deque가 불리한 점이 있습니다.
&lt;img src=&quot;/assets/img/algorithm/Deque.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
&lt;p&gt;흔하게 파이썬에서 알고 있는 리스트입니다. Linked list라고도 불리고 Container의 어느 위치든 O(1)(근사)에 데이터를 삽입하거나 삭제할 수 있지만 Indexing할 때 O(1)에 접근은 불가능합니다. std::list 형태는 Linked list중에서도 Doubly_Linked List이고, std::forward_list는 Singly-Linked List입니다. Singly Linked List는 Doubly Linked List에 비해 맨 뒤에 데이터를 삽입하는게 빠르거나 iterator 자신을 삭제하지 못하는 등 기능이 제한됩니다. 하지만 포인터를 하나 덜 가지기 때문에 연산이 빠르고 메모리가 적게 사용됩니다.
&lt;img src=&quot;/assets/img/algorithm/List.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;associative-containers&quot;&gt;Associative Containers&lt;/h2&gt;
&lt;p&gt;데이터를 정렬된 상태로 유지하는 자료구조입니다. Red-Black Tree(RB-Tree)를 기반으로 하고 데이터의 추가/삭제/접근의 시간복잡도가 O(logN)입니다. 하지만 자료구조의 특성상 연산에 붙는 상수가 크고 메모리가 많이 필요하기 때문에 주의가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;
&lt;p&gt;RB-Tree는 BST의 일종으로 어떤 key 값을 기준으로 데이터를 저장합니다. std::set은 데이터 자체를 key로 사용하고, std::map은 (key, value)쌍을 받아서 사용합니다. 단순히 데이터를 정렬 상태로 유지하고 싶다면 std::set을 (key, value) 데이터 쌍을 key 기준으로 정렬하고 싶다면 std::map을 사용하면 됩니다. (Key 값의 중복이 허용되지 않습니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;multiset&quot;&gt;MultiSet&lt;/h3&gt;
&lt;p&gt;Key값의 중복을 허용하지 않는 Set과 다르게 MultiSet은 Key값의 중복을 허용합니다. 다만 시간 복잡도의 주의가 매우 필요한 편입니다. Multiset은 같은 key를 모두 세고, 모두 접근하는 형식이기 때문에 O(logN + key 데이터 수) 만큼의 시간이 듭니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;unordered-associative-containers&quot;&gt;Unordered Associative Containers&lt;/h2&gt;
&lt;p&gt;해시 값을 사용해 데이터를 저장하는 자료구조입니다. 대부분의 경우 데이터의 추가/삭제/접근이 O(1)이므로 Associative Container보다 효율적입니다. 하지만 데이터를 정렬된 상태로 유지해야 하거나 해시 충돌이 걱정되는 상황이라면 Associative Container를 사용하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;unordered_set&quot;&gt;Unordered_set&lt;/h3&gt;
&lt;p&gt;Data를 중복 없이 저장하고 싶고, 순서가 상관없을 때 사용할 수 있습니다. &lt;br /&gt;
데이터를 여러 개의 Bucket에 나누어 저장하고, 주어진 key의 해시 값과 bucket 크기의 나머지 연산을 통해 어떤 버킷에 들어갈 지 정합니다. 이 때문에 다른 key값이여도 동일한 bucket에 들어갈 수 있습니다. 이를 해시 충돌이라고 하며 각 Bucket을 linked list로 쌍을 저장하여 해결할 수 있습니다. 최악의 시간 복잡도는 O(N) (모든 데이터가 하나의 버킷 &amp;amp; linked list 순회)입니다. std::unordered_set 혹은 Unordered_multiset 형태로 std::unordered_multiset으로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;etc&quot;&gt;ETC…&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;
&lt;p&gt;LIFO(Last-In, First-Out) 형태의 자료구조인 Stack입니다. std::stack을 통해 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;
&lt;p&gt;FIFO(First-In, First-Out) 형태의 자료구조인 Queue입니다. std::queue을 통해 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/Stack_Queue.jpg&quot; width=&quot;40%&quot; height=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;priority-queue매우중요&quot;&gt;Priority-Queue(매우중요!!!)&lt;/h3&gt;
&lt;p&gt;Max heap 형태로 유지되는 container입니다. 데이터가 완전하게 정렬된 상태는 아니지만 최대 혹은 최솟값을 빠르게 찾을 수 있습니다. 연속적으로 데이터의 최댓값 또는 최솟값만 필요할 때 매우 효율적이게 동작합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/STL.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/STL.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Collision Detection System</title>
        <description>&lt;h3 id=&quot;collision-detection-system&quot;&gt;Collision Detection System&lt;/h3&gt;
&lt;p&gt;이번장에서는 Collision Detection System을 하도록 하겠습니다. 이를 위해 시간, 거리, 속도와 가속도를 사용해 sensor의 모션을 재구성합니다. 우리는 간단하고 학습을 위한 용도이기 때문에 속도 또는 가속도는 변하지 않는다는 절대적인 가정을 하고 시작하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-collision-detection-problem&quot;&gt;The Collision Detection Problem&lt;/h3&gt;
&lt;p&gt;Collision Avoidance System(CAS)은 운전을 하는 도중에 충돌이 임박했을 때 운전자에게 알려주거나 brake를 동작하는 보조 장치입니다. CAS는 자동차와의 충돌을 평가하기 위해 TTC(time-to-collision)를 계속해서 계산합니다. 아래 그림에서 노란색 차량과 초록색 차량의 거리는 time 0에서의 거리는 $d_{0}$입니다. 이 때 time $t_{0}$에서 초록색 차량이 속도를 줄이게 된다면, time $t_{1}$에서 노락색 차량과 초록색 차량의 거리는 $d_{1}$이 됩니다. 이것을 사용하여 노란색 차량과 초록색 차량의 거리 $d_{i}$가 0이 되는 시간 $t_{i}$가 TTC 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;cvmconstant-velocity-model&quot;&gt;CVM(Constant Velocity Model)&lt;/h4&gt;
&lt;p&gt;TTC를 계산하기 위해서 우리는 몇가지 가정이 필요합니다. 첫 번째 가정은 노란색 차량과 초록색 차량의 속도는 constant하다는 것입니다. 이것은 eq.1 번의 CVM(Constant Velocity Model) 모델을 만들어줍니다.&lt;/p&gt;

&lt;p&gt;$ eq 1. \quad d(t+\Delta t) = d(t) - v_{0} \cdot \Delta t$&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;camconstant-acceleration-model&quot;&gt;CAM(Constant Acceleration Model)&lt;/h4&gt;
&lt;p&gt;하지만 CVM만 가지고 모델링을 하게되면 정확도가 매우 낮습니다. 그래서 eq 3.과 같은 velocity와 acceleration의 수식을 사용하여 eq 2.번과 같은 CAM 모델을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;$ eq 2. \quad d(t+\Delta t) = d(t) - v(t) \cdot \Delta t - \frac{1}{2}a_{0} \cdot \Delta t^{2}$ &lt;br /&gt;
$ eq 3. \quad v(t+\Delta t) = v(t) - a_{0} \cdot \Delta t $&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;단어&quot;&gt;단어&lt;/h3&gt;
&lt;p&gt;Imminent : 임박한&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Camera_03.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Camera_03.html</guid>
        
        
        <category>sensorfusion</category>
        
      </item>
    
      <item>
        <title>OpenCV</title>
        <description>&lt;h2 id=&quot;opencv&quot;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;matrix-datatype&quot;&gt;Matrix Datatype&lt;/h3&gt;
&lt;p&gt;Opencv는 기본 데이터 형식 cv::Mat datatype에 이미지를 저장하고 조작합니다. 이 형태는 다양한 차원의 숫자를 처리할 수 있으며 raster scan order이라 불리는 방식으로 정렬되어 저장됩니다. 2D image인 grayscale image의 경우 데이터가 행으로 구성되고 각 행이 차례대로 등장합니다. 3D인 RGB의 경우 평면으로 배열이 되어있으며, 각 평면은 한 줄씩 채워지고 평면이 차례대로 채워집니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/sensorfusion/Raster_Scan.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;manipulating-matrices&quot;&gt;Manipulating Matrices&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;fixed-pixel-type&quot;&gt;Fixed Pixel Type&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CV_8UC1 : 8-bit unsigned integer : uchar(0~255)&lt;/li&gt;
  &lt;li&gt;CV_8UC3 : 8-bit signed integer : uchar with 3-D&lt;/li&gt;
  &lt;li&gt;CV_8SC1 : 8-bit signed integer : schar(-128~127)&lt;/li&gt;
  &lt;li&gt;CV_16UC1 : 16-bit unsigned integer : ushort(0~65535)&lt;/li&gt;
  &lt;li&gt;CV_16SC1 : 16-bit signed integer : short(-32768~32767)&lt;/li&gt;
  &lt;li&gt;CV_32SC1 : 32-bit signed integer : int(-21…~21…)&lt;/li&gt;
  &lt;li&gt;CV_32FC1 : 32-bit floating-point number : float(-FLT_MAX~FLT_MAX)&lt;/li&gt;
  &lt;li&gt;CV_64FC1 : 64-bit floating-point number : double(-DBL_MAX~DBL_MAX)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;create-matrix&quot;&gt;Create Matrix&lt;/h4&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nrows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;480&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;640&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create 1D uchar(0~255) with size (480, 640) Matrix&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CV_8UC1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scalar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// White Screen&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create 3D uchar(0~255) with size (480, 640 Matrix)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m3_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m3_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CV_8UC3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// three-channel matrix with 8bit unsigned elements&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m3_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scalar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Blue Screen(BGR types)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;change-pixels&quot;&gt;Change Pixels&lt;/h4&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;changePixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create matrix&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nrows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;480&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;640&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CV_8UC1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// two-channel matrix with 8bit unsigned elements&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scalar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//black&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;230&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// STUDENT TASK : loop over all columns and set matrix elements to 255&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ncols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// loop over all columns&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m1_8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// set r, c elements to 255&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;function&quot;&gt;Function&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;cvmatcreate&quot;&gt;cv::Mat::create&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;create(int rows, int cols, int types) : rows * cols 이미지를 types(Fixed Pixel Type) 형태로 생성&lt;/li&gt;
  &lt;li&gt;create(int size, int types) : size * size 이미지를 types(Fixed Pixel Type) 형태로 생성&lt;/li&gt;
  &lt;li&gt;create(int dim, int* size, int types) : size크기의 배열을 ndims의 크기로 생성(ex 200, arr[200&lt;em&gt;200] -&amp;gt; 200&lt;/em&gt;200 이미지)&lt;/li&gt;
  &lt;li&gt;create(std::vector&amp;lt;int&amp;gt;&amp;amp; sizes, int types) : vector 형태의 배열을 types 형태의 이미지로 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;cvmatsetto&quot;&gt;cv::Mat::setTo&lt;/h3&gt;
&lt;p&gt;setTo(inputArray value, inputArray mask) : Matrix의 mask 영역을 value로 설정&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;cvnamedwindow---highguihpp&quot;&gt;cv::namedWindow -&amp;gt; highgui.hpp&lt;/h3&gt;
&lt;p&gt;namedWindow(const string &amp;amp;winname, int flags) : winname이름의 types 형태 윈도우를 생성&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;cvimshow---highguihpp&quot;&gt;cv::imshow -&amp;gt; highgui.hpp&lt;/h3&gt;
&lt;p&gt;imshow(const string &amp;amp;winname, InputArray mat) : matrix를 winname이름의 윈도우에 Display&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;library&quot;&gt;Library&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;opencv2corecorehpp&quot;&gt;opencv2/core/core.hpp&lt;/h4&gt;
&lt;p&gt;코어 모듈은 기본적인 object types나 함수를 포함하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;opencv2highguihighguihpp&quot;&gt;opencv2/highgui/highgui.hpp&lt;/h4&gt;
&lt;p&gt;highgui 모듈은 유저의 입력이나 display를 사용할 수 있는 UI 함수를 포함하고 있습니다. 자주 사용하는 cv::imshow가 여기 속해있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;opencv2imgprocimgprochpp&quot;&gt;opencv2/imgproc/imgproc.hpp&lt;/h4&gt;
&lt;p&gt;imgproc 모듈은 image transformations(filtering, geometric transformation, feature detection, tracking과 같은) 함수를 포함하고 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;opencv2features2dfeatures2dhpp&quot;&gt;opencv2/features2d/features2d.hpp&lt;/h4&gt;
&lt;p&gt;feature2d 모듈은 detection, describing, matching keypoints과 같은 함수를 포함하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;단어&quot;&gt;단어&lt;/h3&gt;
</description>
        <pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Camera_02.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Camera_02.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>Camera Start!!</title>
        <description>&lt;h2 id=&quot;camera&quot;&gt;Camera&lt;/h2&gt;
&lt;p&gt;이번장에서는 카메라에 대해서 학습하도록 하겠습니다. &lt;br /&gt;
카메라는 2D Image 정보를 해석할 수 있습니다. 이는 인간의 눈과 같은 단점을 가지기도 합니다.(ex Darkness, 빛번짐, 많은 비…) 하지만 이러한 점은 사람의 Visual Perception을 기반으로 구성된 우리 환경에서 강점으로 다가올 수 있습니다.(ex 신호등은 빨간 주황 초록 …). 따라서 우리는 카메라에 대해서 더 나아가 이미지를 처리하는 기술들(Image Processing &amp;amp; Computer Vision)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;카메라 기술 &amp;amp; 광학&lt;/li&gt;
  &lt;li&gt;Image Processing &amp;amp; Computer Vision&lt;/li&gt;
  &lt;li&gt;Sensur Fusion with Lidar&lt;/li&gt;
  &lt;li&gt;Project : Collision Avoidance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;에 대해서 학습하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;camera--rader--lidar&quot;&gt;Camera &amp;amp; Rader &amp;amp; Lidar&lt;/h3&gt;
&lt;p&gt;Sensor Fusion을 하는 이유는 각각 센서들이 가지고 있는 장점들이 다르기 때문입니다. 표는 다음과 같이 각각의 센서들이 좋은 점과 나쁜 점을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/SensorTable.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Camera Technology 
카메라 기술은 이미지를 3D Space로 재구성 할 때 많은 도움이 되며, 카메라 geometry와 coordinate system을 배우는 것이 중요합니다. 따라서 이번 장에서는 Camera Basic Technology(pinhole camera, lenses …)에 대해서 학습합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;pinhole-camera&quot;&gt;Pinhole Camera&lt;/h3&gt;
&lt;p&gt;간단한 카메라는 Ojbect 사이에 작은 구멍(Pinhole)이 있는 빛 장벽을 배치하여 설계할 수 있습니다. 물체에 의해 반사된 빛은 핀홀을 통과하여 이미지로 저장하는 감광성(빛에 노출됐을 때 반응하는) 센서에 도달하게 됩니다. 핀홀이 작은 이유는 Object의 여러 부분에서 발생하는 빛들이 중첩되어 이미지가 Blurring 되는 것을 방지하기 위해서입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/PinHole.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pinhole 카메라에서 Photosensitive Surface는 왼쪽에 Image Plane입니다. Camera center인 pinhole과 image plane까지의 수직 거리를 focal length $f$라 부릅니다. &lt;br /&gt;
오프젝트의 한 점 포인트 $P$에서 반사된 빛을 image plane에 $P’$으로 매핑시키면 아래 그림과 같이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/PointMapping.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 $P$와 $P’$의 관계는 다음과 같이 나타낼 수 있습니다. &lt;br /&gt;
$\overrightarrow{P} = \begin{bmatrix} x \\ y \\ z \\ \end{bmatrix} \rightarrow \overrightarrow{P’} = \begin{bmatrix} x’ \\ y’ \\ \end{bmatrix}$ &lt;br /&gt;
$(1)\;x’\,=\,f\cdot\frac{x}{z} \qquad(2)\;y’\,=\,f\cdot\frac{y}{z}$ &lt;br /&gt;
이 수식을 사용하면 우리는 3D 좌표와 Focal Length를 사용하여 image plane에 생기는 2D 좌표를 획득할 수 있습니다. 하지만 이는 pixel 단위는 아직 아닙니다.&lt;/p&gt;

&lt;h4 id=&quot;pinhole-camera-problem&quot;&gt;Pinhole Camera Problem&lt;/h4&gt;
&lt;p&gt;Pinhole Camera의 가장 큰 문제점은 핀홀을 통과하는 빛의 양이 이미지 센서에 적절한 이미지를 생성하기에 충분하지 않은 것입니다. 그렇다고 핀홀의 크기를 넓혀 빛의 양을 증가시키면 대상 물체의 다른 부분에서 나오는 광선이 중첩되어 Blurring 효과가 발생합니다. 이러한 방법을 해결하는 것이 같은 위치에서 나오는 빛 광선을 포착할 수 있는 Lens를 사용하는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/LargePinhole.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;lenses-and-aperture&quot;&gt;Lenses and Aperture&lt;/h3&gt;
&lt;p&gt;적절한 크기와 위치의 렌즈는 Object Point $P_{1}$ 의 빛 광선을 굴절시켜 image plane의 $ P^{‘}_{1}$ 지점으로 모아줍니다.&lt;/p&gt;

&lt;p&gt;Object Point $ P $의 거리가 더 가깝거나( $P_{2}$ ), 멀리 있는 경우($P_{1}$) image plane에서 point로 나타나지 않습니다. $P_{2}$의 경우 광선의 집합이 이미지 평면에 초점이 맞지 않기 때문에 유한한 반지름을 가진 원에 수렴하게 됩니다.($P_{1}$의 경우도 유사) 이 Blurring한 원을 우리는 COF(circle of confusion)이라 부릅니다. 우리는 조리개(Aperture)를 조절하여 이러한 blurring circle을 줄일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Aperture.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조리개를 작게 줄이면 &lt;br /&gt;
렌즈의 바깥부분을 통해 들어오는 빛이 차단되면서, image plane에 맺히는 COF의 크기가 줄어들게 됩니다. 그러나 적은 빛이 들어오기 때문에 이미지가 어둡게 생성됩니다.&lt;/li&gt;
  &lt;li&gt;조리개를 크게 만들면 &lt;br /&gt;
더 많은 빛이 이미지 영역에 들어오면서 더 밝은 이미지를 생성합니다. 하지만 COF의 크기가 커지게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Aperture_Image.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사진에서는 F값(조리개 값)이 높아 질수록 렌즈 조리개 구멍이 작아집니다.(16일 때 가장 어두움)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;카메라-왜곡&quot;&gt;카메라 왜곡&lt;/h3&gt;
&lt;p&gt;여기까지 우리는 3D 물체가 PinHole Camera에서 상을 맺히는 것을 배웠습니다. 카메라에서도 3D 물체가 2D Image 상이 맺힐 때 유사한 과정을 거치지만, 실제로는 렌즈는 렌즈 유형에 따라 이미지에 왜곡을 발생시킵니다. 우리는 이런 왜곡을 “Radial Distortion”이라 부릅니다. 이러한 현상은 렌즈와 image plane까지의 focal length가 직경에 걸처 “균일”하지 않기 때문에 발생합니다. 따라서 카메라 중심(광축)과 렌즈를 통과하는 광선 사이의 거리에 따라서 렌즈의 확대 효과가 달라지게 됩니다. 우리는 배율이 증가해서 나오는 왜곡 효과를 “Pin Cushion Distortion”, 배율이 감소해서 나오는 왜곡 효과를 “Barrel Distortion”이라고 합니다. 광각 렌즈를 사용할 때 일반적으로는 Barrel Distortion이 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Distortion.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지에서 Object의 정보를 얻기 위해서 왜곡 정보는 제거되거나 완화되어야 합니다. 이러한 과정을 우리는 Calibration이라고 부릅니다. 이 과정은 카메라 렌즈 설정에 대해 Distortion Parameters를 개별적으로 계산할 수 있는 과정을 의미합니다. 이는 일반적으로 알려진 Planar Checkerboard 사진을 여러장 촬영함으로써 수행할 수 있습니다. Planar Checkerboard는 기하학적 형상에서 렌즈와 이미지 센서 매개변수를 강력하게 도출할 수 있는 형태의 보드로 아래 그림과 같은 모양입니다. 우리는 이 Planar Checkerboard를 사용하여 카메라 이미지에서 왜곡을 제거하는데 이 과정을 Rectification(정류)라 부릅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Checker_Board.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;projection-of-points-in-3d-space-onto-the-digital-image&quot;&gt;Projection of points in 3D Space onto the digital Image&lt;/h3&gt;
&lt;p&gt;앞서 말한바와 같이 3D Space의 점을 Image Plane에 Projection(투영)한 결과는 pixel로 이루어진 digital images에 완벽하게 일치하지 않습니다. 이번에는 Continuous한 결과를 Discrete한 pixel로 표현하는 digital 이미지에 대해 이해해 보도록 하겠습니다.(아래 그림 참조)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Digital_Image.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;coordinate-system으로-변환&quot;&gt;Coordinate System으로 변환&lt;/h4&gt;
&lt;p&gt;Camera Center Position $O$는 axes $i, j, k$로 표현할 수 있으며, $k$는 image plane으로의 방향을 나타냅니다. Position $C^{‘}$은 k가 image plane과 교차하는 지점으로 이미지 좌표의 중심을 나타내는 principal point 혹은 center point입니다. 우선 Point $P$를 image plane에 projection시키기 위해 center point $O$에서 Point $P$를 빼서 image plane에 맺히는 Point $\overrightarrow{P}$를 계산할 수 있습니다.(image plane의 좌측 코너) 이 때, image plane에 맺히는 $\overrightarrow{P}$는 $\begin{bmatrix} P_{x} &amp;amp; P_{y} &amp;amp; P_{z} \end{bmatrix}$  로 표현할 수 있습니다. 다음은 transformation process로 미터로 계산한 $\overrightarrow{P}$를 pixel 좌표로 이동시키는 것입니다. 이 때 우리는 아래 투영 방정식을 통해 얻을 수 있는 $k$와 $l$ 파라미터를 사용하여 meters를 pixel로 변환할 수 있습니다.($l, k$는 추후에 mapping operation을 할 때 필요한 calibration matrix에 중요하게 사용됩니다.) 이 때, y좌표가 좌측 하단에 있는 것이 아닌 좌측 상단에 있는것을 꼭 기억해야 합니다. &lt;br /&gt;
$ (1)\qquad \overrightarrow{P} \rightarrow \overrightarrow{P^{‘}}$ &lt;br /&gt;
$ (2)\qquad \begin{pmatrix} x, &amp;amp; y, &amp;amp; z \end{pmatrix}^{T} \rightarrow ( \underbrace{f \cdot k}_{\alpha} \cdot \frac{x}{z} +c_x$, $\underbrace{f \cdot l}_{\beta}\cdot\frac{y}{z} + c_{y} )^{T}$ &lt;br /&gt;
$ [k,l] = pixels/m $ \&lt;/p&gt;

&lt;p&gt;일반적으로 이와 같은 rectification으로 m를 픽셀로 변환할 때, 정확하게 discrete한 pixel에 일치하지 않습니다. 이러한 점을 보완하기 위해 interpolation을 사용하는데 이러한 interpolation errors를 피하기 위해서 원본 이미지를 사용하는 것은 합리적입니다. feature tracking과 같은 task에서 origin image를 사용하고 rectification을 적용하는 것이 의미 있습니다. 하지만 deep learning을 사용하는 경우는 distortion이 detection error를 가져올 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;image-and-bayer-pattern&quot;&gt;Image and Bayer Pattern&lt;/h3&gt;
&lt;p&gt;이번장에서는 빛 광선이 어떤 파장을 가지고 digitally하게 저장되는 Color Pixel로 변환되는지에 대해서 배우도록 하겠습니다. &lt;br /&gt;
Camera로 이미지를 촬영하면, 빛이 렌즈를 통과하여 이미지 센서에 도달합니다. 이 센서는 얼마나 많은 빛이 들어오는지 등록하는 light sensitive elements로 구성되어있고 그것을 상응하는 electron(..?)의 수로 변경해줍니다.(More Light, More Electron) 일정 노출 시간(Exposure time)이 완료되면, 이 생성된 전자들은 전압으로 변환되며, 최종적으로 A/D-Converter를 통해 이산 숫자로 변환됩니다. 이미지 기술에는 현재 CCD, CMOS 2가지 기술이 주로 사용되고 있습니다. 두 기술 모두 전자를 Voltage(전압)으로 변경시켜주지만 다른 전자를 생성하는 파장을 구분하지 못하는 색맹입니다. 그래서 Color Vision을 하기 위해서 Pixel앞에 특정 파장만을 허용하는 작은 filter elements(also micro-lenses)를 사용합니다. 파장을 색상에 매핑시키는 가장 일반적인 방법은 기본 원색이 개별적으로 통과할 수 있도록 RGB 패턴으로 필터 요소를 배열 하는 것입니다. 이러한 RGB 값들의 색 조합을 사용하면 사람이 볼 수 있는 대부분의 색깔을 만들어 낼 수 있습니다. 또 각 색상을 8비트(0~255까지 256개의 값)로 코딩하면 256&lt;em&gt;256&lt;/em&gt;256=1670만 가지 색상을 생성할 수 있습니다. \&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;bayer-pattern&quot;&gt;Bayer Pattern&lt;/h4&gt;
&lt;p&gt;가장 보편적으로 RGB 패턴을 정렬시키는 방법을 Bayer Pattern이라 부릅니다. 만약 2500 x 2000 = 5백만 화소의 이미지를 가지고 있다면 R, G, B 색을 감지할 수 있는 화소가 5백만개 포함된 이미지 센서를 사용하는 것입니다. 그런데 이 때 각 화소가 RGB를 파악하는 것이 아닌 흑백의 밝기만을 감지하는 monochrome 화소이면 데이터 전송량을 엄청나게 줄일 수 있습니다. 이 때, 인간의 시각 특성에 따라서 G가 50% R, B가 25씩 되도록 아래 그림과 같이 교차 배치하는 방식을 Bayer Pattern이라 합니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/sensorfusion/Bayer_Pattern_Filter.jpg&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;ccdcharge-coupled-device&quot;&gt;CCD(Charge-Coupled Device)&lt;/h4&gt;
&lt;p&gt;CCD 센서는 각 그림에서 수집된 전자들이 단일 또는 소수의 출력 노드를 통해 칩에서 전송됩니다. 그 이후 전하가 전압으로 변경되고 버퍼링 되어 아날로그 신호로 전송됩니다. 그 이후 신호가 증폭되고 센서 외부의 A/D 변환기를 통해 discrete한 숫자로 변환됩니다. CCD 센서는 CMOS에 비해 높은 감광도와 적은 노이즈를 가지고 있었지만 오늘날은 그 차이가 많이 줄어 들었습니다. 반면에 CCD는 높은 생산 가격과 높은 전력소비를 하는 단점을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;cmoscomplementary-metal-oxide-semiconductor&quot;&gt;CMOS(Complementary Metal-oxide Semiconductor)&lt;/h4&gt;
&lt;p&gt;CMOS 센서는 반도체 소자를 이용해 빛의 세기를 측정합니다. 반도체라는 것은 전압을 걸지 않으면 부도체, 전압을 걸면 전기가 흐르는 도체가 되는데 이를 사용하여 측정값을 한번에 병렬로 읽는 방식입니다. 또한 병렬로 읽기 때문에 CCD와 달리 빛의 세기를 측정하는 회로 장치가 셀 마다 전부 존재합니다. 이러한 특징 때문에 소비 전력이 작고, 고속 처리가 가능한 장점을 가지고 있습니다. 단점은 CMOS센서는 회로가 가지고 있는 (재질적, 공정적, 물리적)편차를 가지고 있기 때문에 전위를 측정하는 방식이 동일하지 않기 때문에 낮은 감도를 가지고 있습니다. 또한 암 전류가 잔존하여 노이즈가 많이 발생할 수 있는 단점을 가지고 있습니다. 하지만 오늘날 기술들이 비약적으로 발전하면서 이러한 문제를 많이 해결하였고 요즘은 CMOS를 대부분 사용하는 추세입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;iframe width=&quot;720&quot; height=&quot;405&quot; src=&quot;https://www.youtube.com/embed/nxUDHcZl1uo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;단어&quot;&gt;단어&lt;/h3&gt;
&lt;p&gt;Gleaned : 얻은, 수집된 &lt;br /&gt;
Glean : 얻다 수집하다 &lt;br /&gt;
Embark : 배에 승선하다 &lt;br /&gt;
Embork : 시동을 걸다 &lt;br /&gt;
Contraption : 기구 장치 &lt;br /&gt;
Matured : 다 큰, 분별 있는 &lt;br /&gt;
Profoundly : 깊이 &lt;br /&gt;
Adverse : 불리한 부정적인 &lt;br /&gt;
Preceding : 선행의 &lt;br /&gt;
Fierce : 사나운 &lt;br /&gt;
Debate : 토론 논쟁 &lt;br /&gt;
Unattractive : 매력 없는 &lt;br /&gt;
Emanating : 방출 중 &lt;br /&gt;
Superimposed : 겹친 &lt;br /&gt;
Aperture : 구멍 &lt;br /&gt;
Photosensitive : 감광성 &lt;br /&gt;
Decent : 적절한 &lt;br /&gt;
Emanate : 발하다 &lt;br /&gt;
Aperture : 구멍, 개구부 &lt;br /&gt;
Refract : 굴절시키다 &lt;br /&gt;
Such that : 그런식으로 &lt;br /&gt;
Concentric : 중심이 같은 &lt;br /&gt;
Magnification : 확대 &lt;br /&gt;
Mitigate : 완화하다 &lt;br /&gt;
Along with : ~와 함께 &lt;br /&gt;
Along : ~를 따라 &lt;br /&gt;
Advisible : 권고할만한, 가치있는 &lt;br /&gt;
Electrons : 전자&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Camera_01.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Camera_01.html</guid>
        
        
        <category>sensorfusion</category>
        
      </item>
    
      <item>
        <title>Lidar Obstacle Detection Code Review</title>
        <description>&lt;h2 id=&quot;code-review&quot;&gt;Code Review&lt;/h2&gt;
&lt;p&gt;지금까지 우리는 Lidar Obstacle Detection을 하기 위해 달려 왔고 크게 4가지를 배웠습니다. 이번 포스트에서는 이 함수들에 관한 code Review 및 Refactoring을 하도록 하겠습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Point Cloud Segmentation(RANSAC)&lt;/li&gt;
  &lt;li&gt;Point Cloud Clustering(KD-Tree)&lt;/li&gt;
  &lt;li&gt;Point Cloud Clustering(Euclidean Clustering)&lt;/li&gt;
  &lt;li&gt;Point Cloud Downsampling &amp;amp; Filtering(Voxel Grid)&lt;/li&gt;
  &lt;li&gt;Point Cloud Downsampling &amp;amp; Filtering(Region of Interest)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-point-cloud-segmentationransac&quot;&gt;1. Point Cloud Segmentation(RANSAC)&lt;/h3&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ransac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PointCloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PointXYZ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxIterations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distanceTol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// cloudSize to get random index&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloudSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxIterations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// randomly sample subset&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// select two points.(Line Ransac)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloudSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// set cant contain same key&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// if inliers size is not two select same key in random sample&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// take out two point that are in the form of pcl::PointXYZ format&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pcl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PointXYZ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;


        &lt;span class=&quot;c1&quot;&gt;// make line AX+BY+C = 0&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// iterate all points&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cloudSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// skip select subset points&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// calculate distance&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cloud&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// if distance &amp;lt; distanceTol&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distanceTol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// it is inliers&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// want to extract plain(biggest one)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inliersResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inliersResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inliers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inliersResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/2023/01/SensorFusion_05.html&quot;&gt;참조&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/KangSooHan/SensorFusion/blob/main/SFND_Lidar_Obstacle_Detection/src/quiz/ransac/ransac2d.cpp&quot;&gt; github &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-point-cloud-clusterkd-tree&quot;&gt;2. Point Cloud Cluster(KD-Tree)&lt;/h3&gt;

</description>
        <pubDate>Tue, 10 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Lidar_Obstacle_Detection.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Lidar_Obstacle_Detection.html</guid>
        
        
        <category>sensorfusion</category>
        
      </item>
    
      <item>
        <title>선물사기(DFS)</title>
        <description>&lt;h2 id=&quot;선물-사기&quot;&gt;선물 사기&lt;/h2&gt;
&lt;p&gt;겟 지는 여행을 갔다오면서 선물을 사려고 한다. &lt;br /&gt;
여행지는 x, y크기로 a~z까지 선물이 있다. &lt;br /&gt;
겟 지는 선물을 모으는 것을 싫어하여 중복된 선물을 사지 않도록 계획을 짰다. &lt;br /&gt;
이 때, 겟 지가 최대 몇 개의 선물을 살 수 있는지 알아보자.
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;여행지&quot;&gt;여행지&lt;/h3&gt;

&lt;table rules=&quot;groups&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;c&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;d&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;c&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;입력&quot;&gt;입력&lt;/h4&gt;
&lt;p&gt;r, c, 선물(a~z)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;input&quot;&gt;[INPUT]&lt;/h4&gt;

&lt;div style=&quot;background-color: rgb(50, 50, 50); width: 10%; color: white&quot;&gt;
2, 4 &lt;br /&gt;
caab &lt;br /&gt;
dbac
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;output&quot;&gt;[OUTPUT]&lt;/h4&gt;
&lt;div style=&quot;background-color: rgb(50, 50, 50); width: 10%; color: white&quot;&gt;
4
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;to-solve&quot;&gt;To Solve&lt;/h3&gt;
&lt;p&gt;문제를 해결하기 위해서 DFS로 문제를 접근하였다.&lt;br /&gt;
DFS 제한 조건에는 방문 하였는지 check배열과 알파벳을 가지고 있는지 alpha배열을 확인하고 좌표가 MAP 안에 있는지 확인하면서 재귀적으로 접근하였다.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// x좌표 y좌표 cnt카운트&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// alphabet이 있으면 종료&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 없을 시 cnt가 ans보다 크면 변경&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// check와 alpha를 1로 변경&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 4방향으로 돌면서&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 조건 확인&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 재귀&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 백트래킹&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/KangSooHan/algorithm/blob/main/SWExpert/DFS/%EC%84%A0%EB%AC%BC%EC%82%AC%EA%B8%B0/main.cpp&quot;&gt;Code&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/%EC%84%A0%EB%AC%BC%EC%82%AC%EA%B8%B0.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/%EC%84%A0%EB%AC%BC%EC%82%AC%EA%B8%B0.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Tree</title>
        <description>&lt;h2 id=&quot;tree&quot;&gt;TREE&lt;/h2&gt;
&lt;p&gt;Tree는 상위 원소에서 하위 원소로 내려가면서 확장되는(계층 관계를 가지는) 나무 모양의 구조를 가진 비 선형 구조의 자료구조 입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Root
노드 중 최상위 노드&lt;/li&gt;
  &lt;li&gt;Node
Tree의 원소 &lt;br /&gt;
최상위 노드인 루트 노드가 있으며, 자식 부모 관계를 가진 부모 노드와 자식 노드 &lt;br /&gt;
단말 노드는 차수가 0인(자식 노드가 없는) 노드&lt;/li&gt;
  &lt;li&gt;Edge(간선)
간선은 노드를 연결하는(자식 노드와 부모 노드를 연결하는) 선&lt;/li&gt;
  &lt;li&gt;차수
노드에 연결된 자식 노드의 수
Tree의 차수는 Tree에서 가장 큰 차수를 의미&lt;/li&gt;
  &lt;li&gt;높이
노드의 높이 : 루트에서 노드에 이르는 간선의 수 : Level
Tree의 높이 : Tree에 있는 노드의 높이 중 가장 큰 값&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/Tree.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;binary-tree&quot;&gt;Binary Tree&lt;/h2&gt;
&lt;p&gt;Binary Tree는 Tree의 일종으로 모든 노드들이 2개의 SubTree를 갖는 특별한 형태의 Tree를 의미합니다.&lt;br /&gt;
노드가 자식 노드를 최대한 2개까지만 가질 수 있는 Tree(left child node, right child node)형태 입니다. &lt;br /&gt;
레벨 i에서의 노드의 최대 $2^i$, 노드의 최소 개수는 $h+1$, 노드의 최대 개수는 $2^{h+1}-1$입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포화 이진 트리(Full Binary Tree)
모든 레벨의 노드가 포화 상태인 Binary Tree&lt;/li&gt;
  &lt;li&gt;완전 이진 트리(Complete Binary Tree
노드번호 1번부터 n번까지 빈 자리가 없는 Binary Tree&lt;/li&gt;
  &lt;li&gt;Skewed Binary Tree(편향 이진 트리)
한쪽 방향의 자식 노드만을 가진 Binary Tree&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;순회traversal&quot;&gt;순회(Traversal)&lt;/h3&gt;
&lt;p&gt;순회는 Tree의 각 노드를 중복되지 않게 전부 방문(Visit)하는 방법입니다. Tree는 비선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전위 순회(Pre-order) : 루트 $\rightarrow$ 왼 $\rightarrow$ 오&lt;/li&gt;
  &lt;li&gt;중위 순회(In-order) : 왼 $\rightarrow$ 루트 $\rightarrow$ 오&lt;/li&gt;
  &lt;li&gt;후위 순회(Post-order) : 왼 $\rightarrow$ 오 $\rightarrow$ 루트&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/Traversal.jpg&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;이진-탐색-트리binary-search-treebst&quot;&gt;이진 탐색 트리(Binary Search Tree(BST))&lt;/h2&gt;
&lt;p&gt;이진 탐색 트리는 탐색 작업을 효율적으로 하기 위한 자료구조입니다. BST는 모든 원소가 서로 다른 유일한 키를 가지게 됩니다. 또한, 부모 노드의 값을 기준으로 왼쪽 Subtree와 오른쪽 Subtree를 구성하게 됩니다. 따라서 in-order traversal를 실행하면 오름차순으로 정렬된 값을 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/BST.jpg&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;
&lt;p&gt;BST는 다음과 같은 삭제 삽입 연산을 통해서 형태를 유지합니다.
 삽입&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;node = NULL인 경우
이는 서브트리가 비어있는 경우입니다. x를 추가하면 x가 하나뿐인 서브트리가 생기므로 x 노드를 만들어 추가해주면 됩니다.&lt;/li&gt;
  &lt;li&gt;node의 자식에 x가 들어가야 하는 경우
자식 서브트리에 x를 삽입한 뒤 서브트리의 루트를 그 방향의 자식으로 만들면 됩니다.&lt;/li&gt;
  &lt;li&gt;node = x 인 경우
이미 존재하는 경우이기 때문에 return 하면 됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/BST_insert.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삭제&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;node = NULL 인 경우
이는 서브트리가 없는 경우임으로 return하면 됩니다.&lt;/li&gt;
  &lt;li&gt;node = x인 경우
node를 삭제해야 하는데 2가지 케이스가 있습니다.
    &lt;ol&gt;
      &lt;li&gt;Node의 한 쪽 자식이 없는 경우
노드를 삭제 하면 됩니다. 그 이후 Subtree와 부모 노드를 연결하면 됩니다.&lt;/li&gt;
      &lt;li&gt;Node의 양 쪽 자식이 있는 경우
Tree의 형태를 유지하기 위해서는 Subtree의 루트가 왼쪽보다는 크고 오른쪽 보다는 작아야 합니다. 이를 유지하기 위해서 삭제 노드의 값을 오른쪽 Subtree에서 가장 작은 값(left$\rightarrow$left$\rightarrow$…) 혹은 왼쪽 Subtree에서 가장 큰 값(right$\rightarrow$right$\rightarrow$…)로 대체하면 됩니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/BST_remove.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;&lt;br /&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;p&gt;구현
Binary Tree는 배열과 리스트로 구현할 수 있습니다.
&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;배열-구현&quot;&gt;배열 구현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;장점 : 구현이 쉬움&lt;/li&gt;
  &lt;li&gt;단점 : 메모리 공간 낭비, 노드가 자식 노드를 최대한 2개까지만 가질 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Binary Tree에 각 노드 번호를 다음과 같이 부여&lt;/li&gt;
  &lt;li&gt;루트 번호를 1로함&lt;/li&gt;
  &lt;li&gt;레벨 N에 있는 노드에 대해서 왼쪽부터 오른쪽까지 $2^n\sim2^{n+1}-1$ 번호를 차례대로 부여
    &lt;ul&gt;
      &lt;li&gt;노드 번호가 i인 노드의 부모 노드 : i/2&lt;/li&gt;
      &lt;li&gt;노드 번호가 i인 노드의 왼쪽 자식 노드 : 2*i&lt;/li&gt;
      &lt;li&gt;노드 번호가 i인 노드의 오른쪽 자식 노드 : 2*i+1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/TreeArray.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;리스트-구현&quot;&gt;리스트 구현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;장점 : 구현이 어려움&lt;/li&gt;
  &lt;li&gt;단점 : 메모리 효율이 좋음, 자식 노드를 여러명 가질 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/TreeList.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/KangSooHan/algorithm/blob/main/DataStructure/Tree.cpp&quot;&gt;Tree 구현&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/KangSooHan/algorithm/DataStructure/BST.cpp&quot;&gt;BST 구현&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Tree.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Tree.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>POST 해야할 것들?</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;calibration&quot;&gt;Calibration!!!!!&lt;/h3&gt;

&lt;h3 id=&quot;smart-pointer&quot;&gt;Smart Pointer&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;dot-product--cross-product&quot;&gt;Dot Product &amp;amp; Cross Product&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;highway-simulation-ransac-부수기&quot;&gt;HighWay Simulation RANSAC 부수기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;kd-tree-clustering-code-부수기&quot;&gt;KD-TREE clustering Code 부수기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;생성자&quot;&gt;생성자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;소멸자&quot;&gt;소멸자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;복사-생성자&quot;&gt;복사 생성자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;기본-대입-연산자&quot;&gt;기본 대입 연산자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;class-default--delete&quot;&gt;class default &amp;amp; delete&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;bst-tree-주석달기&quot;&gt;BST, TREE 주석달기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;pca---링크-달기-sf-06번&quot;&gt;PCA -&amp;gt; 링크 달기 SF 06번&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;우측-값-참조-및-vector-reallocation&quot;&gt;우측 값 참조 및 vector reallocation&lt;/h3&gt;

</description>
        <pubDate>Thu, 05 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Need_to_Post.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Need_to_Post.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>Class Default &amp; Delete</title>
        <description>&lt;h2 id=&quot;가독성을-위한-default와-delete-키워드&quot;&gt;가독성을 위한 default와 delete 키워드&lt;/h2&gt;
&lt;p&gt;클래스 작성 시 우리가 직접 작성하지 않아도 기본적으로 컴파일러가 생성해 주는 것이 있다. 그 대표적인 예로 기본 생성자, 기본 소멸자, 기본 복사생성자, 기본 대입 연사자 등이 그렇다. 컴파일러가 생성한 복사 생성자와 대입 연산자는 얕은 복사를&lt;/p&gt;

&lt;h2&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/h2&gt;
&lt;h3 id=&quot;ref&quot;&gt;Ref&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt; 생성자&lt;/a&gt;
 소멸자
 복사 생성자
 기본 대입 연산자&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;-httpsmblognavercompostlistnaverblogidsw4r--참조&quot;&gt;&lt;a href=&quot;https://m.blog.naver.com/PostList.naver?blogId=sw4r&quot;&gt; https://m.blog.naver.com/PostList.naver?blogId=sw4r &lt;/a&gt; 참조&lt;/h1&gt;
</description>
        <pubDate>Thu, 05 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/Class_Default_Delete.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/Class_Default_Delete.html</guid>
        
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>Point Cloud Clustering</title>
        <description>&lt;p&gt;Point Cloud Clustering
Point Cloud에서 Clustering은 보행자, 자동차 등 obstacle들을 찾아내는데 사용합니다. Udacity 강의에서는 KD-TREE를 사용한 Euclidean Clustering을 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;clustering&quot;&gt;Clustering&lt;/h2&gt;
&lt;p&gt;클러스터링(Clustering : 군집화)는 비슷한 개체끼리 한 그룹으로, 다른 개체는 다른 그룹으로 묶는 것을 의미합니다. 클러스터링은 다음과 같이 얘기할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;군집 간 분산(outer-cluster variance) 최대화&lt;/li&gt;
  &lt;li&gt;군집 내 분산(inner-cluster variance) 최소화&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클러스터링은 정답 라벨이 없는 Unsupervised Learning(비지도 학습) 입니다. 이는 그룹 정보 없이 비슷한 개체끼리 군집화 하는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;군집-타당성-평가&quot;&gt;군집 타당성 평가&lt;/h3&gt;
&lt;p&gt;클러스터링 알고리즘은 정답 라벨이 없기 때문에 Accuracy 지표로 표현할 수 없습니다. 또한 최적의 cluster 개수를 알아내는 것은 쉽지 않습니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/sensorfusion/clustering.jpg&quot; width=&quot;60%&quot; height=&quot;40%&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이러한 문제 때문에 clustering은 평가가 어렵습니다. 그래서 군집의 유용성을 다시 말해 군집 간 분산과 군집 내 분산을 기반으로 평가하는 Clustering Validity Index(Dunn Index, Silhouette)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;kd-tree&quot;&gt;KD-Tree&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/KDTree.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;K-D Tree는 공간을 기반으로 partitioning하는 B-Tree(&lt;a href=&quot;/2023/01/Tree.html&quot;&gt;참조&lt;/a&gt;)로, 점들을 k-차원 공간에서 정리합니다. K-D Tree는 다음과 같이 동작합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;k차원의 점들이 N개 존재&lt;/li&gt;
  &lt;li&gt;X좌표를 기준으로 X의 중간값을 찾고 이진 트리화&lt;/li&gt;
  &lt;li&gt;자식 노드들은 각각 노드마다 Y의 중간값을 찾고 이진 트리화&lt;/li&gt;
  &lt;li&gt;손자 노드들은 각각 노드마다 Z의 중간값을 찾고 이진 트리화&lt;/li&gt;
  &lt;li&gt;증손자 노드들은 각각 노드마다 다시 X의 중간값을 찾고 이진 트리화..&lt;/li&gt;
  &lt;li&gt;반복&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/BinaryTree.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;searching-points-in-a-kd-tree&quot;&gt;Searching Points in a KD-Tree&lt;/h3&gt;
&lt;p&gt;KD-Tree를 이용하여 거리가 distanceTol(distanceTolerance) 이내인 점들을 찾아내는 방법입니다. &lt;br /&gt;
루트를 시작으로 반복하며 search 함수를 진행하면서 거리 이내의 포인트들을 찾아낼 수 있습니다. &lt;br /&gt;
&lt;strong&gt;&amp;lt; Pseudo Code &amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;if node가 nullptr이면 종료&lt;/li&gt;
  &lt;li&gt;만일 현재 노드의 점과 target 점의 X,Y,Z의 거리가 distanceTol보다 크다면 종료(최적화를 위해)&lt;/li&gt;
  &lt;li&gt;만일 distance D $\sqrt{x^2 + y^2 + z^2}$의 값이 distanceTol보다 크다면 종료(거리 이내에 없기 때문에)&lt;/li&gt;
  &lt;li&gt;KD-Tree의 Depth 기준에 맞게 노드의 점과 target 점의 X(0)Y(1)Z(2) 거리가 distanceTol이내에 있으며
    &lt;ul&gt;
      &lt;li&gt;0보다 작으면 search(node$\rightarrow$left)&lt;/li&gt;
      &lt;li&gt;0보다 크면 search(node$\rightarrow$right)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 동작하면 KD-Tree를 이용하여 범위 안에 속하는 점들을 빠르게 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;euclidean-clustering&quot;&gt;Euclidean Clustering&lt;/h3&gt;
&lt;p&gt;Euclidean Clustering은 거리를 기준으로 Clustering하는 기법 중 하나입니다. 지금까지 우리는 Euclidean Clustering을 하기 위해 KD-Tree와 KD-Tree를 활용한 근접 점들을 찾는 방법에 대해서 배웠습니다.&lt;br /&gt;
Euclidean Clustering은 다음과 같이 동작합니다. \&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;각각 점들을 순회하면서&lt;/li&gt;
  &lt;li&gt;만일 그 점이 처리되지 않은 점이라면
    &lt;ul&gt;
      &lt;li&gt;Searching Point를 통해서 그 점과 근접한 점들을 획득하고&lt;/li&gt;
      &lt;li&gt;그 점들을 순회하면서 Searching Point를 하며 다시 근접 점들을 획득&lt;/li&gt;
      &lt;li&gt;만약 이미 처리되어 있는 점이라면 스킵&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 하나의 Cluster를 만들고&lt;/li&gt;
  &lt;li&gt;계속해서 순회하면 집단의 Cluster를 획득&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 동작하면 Euclidean Clutering이 완성됩니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Euclidean Clustering.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;bounding-box&quot;&gt;Bounding Box&lt;/h3&gt;
&lt;p&gt;이렇게 획득한 Cluster를 기준으로 Bounding Box를 생성하면 더욱 쉽게 확인할 수 있습니다. &lt;br /&gt;
Bounding Box는 각각 점들의 최소 최대 값을 기준으로 생성할 수 있습니다. 다만, 이렇게 생성할 경우 아래 왼쪽 경우처럼 박스가 Fit하게 생성되지 않을 수 있습니다. &lt;br /&gt;
이러한 문제를 PCA를 이용하여 PCA Boxes를 생성하면 오른쪽과 같이 생성할 수 있습니다. PCA의 개념은 MATH 항목을 참조하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/sensorfusion/Box_Rotate.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;단어&quot;&gt;단어&lt;/h3&gt;
&lt;p&gt;Alternating : 교대로 &lt;br /&gt;
Consecutive : 연이은 &lt;br /&gt;
Dereference : 역참조 &lt;br /&gt;
Proximity : 근접성 &lt;br /&gt;
Negligible : 무시할 수 있는 &lt;br /&gt;
Reap : 베다, 보상을 받다, 받다 &lt;br /&gt;
Innermost : 가장 깊숙히 &lt;br /&gt;
Coincide : 일치하다 &lt;br /&gt;
Chronological : 연대순&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2023/01/SensorFusion_06.html</link>
        <guid isPermaLink="true">http://localhost:4000//2023/01/SensorFusion_06.html</guid>
        
        
        <category>sensorfusion</category>
        
      </item>
    
  </channel>
</rss>
