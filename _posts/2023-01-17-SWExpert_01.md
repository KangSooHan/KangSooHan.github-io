---
title: Bits 연산
category: algorithm
layout: post
use_math: true
---

### 비트(bit)
컴퓨터에서 자료를 표현하기 위해 비트를 사용합니다. \
* 1bit = 0 또는 1
* 1byte = 8 bits

우리가 사용하는 Window에는 32 비트 혹은 64 비트 시스템이 있습니다. 여기서 얘기하는 비트가 우리가 배우려는 비트입니다. 우리가 프로그램을 실행할 때 CPU가 데이터를 처리하는데 이 때 처리하는 데이터의 최소 단위인 레지스터의 크기가 32bits 혹은 64bits라는 의미입니다. 레지스터는 CPU(Central Processing Unit)가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 기억 장치 입니다. 레지스터는 명령을 처리하기 위해서 이들에 대한 주소 및 명령의 종류를 저장할 수 있는 기억 공간입니다. 이전에 32 bits 시스템일 경우 최대 2^32 bits 대략 4GB정도의 메모리만 인식이 가능하여 64bits 크기의 운영체제를 많이 사용하고 있습니다.

<br>
### 비트 연산자
아래의 표는 6가지 비트 연산자입니다. 

||비트 연산자|a=0b1010, b=0b0110| 
|:---------:|:--:|:----------------:|
| & | AND | a & b = 0b0010 |
| \| | OR | a \| b = 0b1110 |
| ^ | XOR | a ^ b = 0b1100 |
| ~ | NOT | ~a = 0b0101 |
| << | left shift | a << 1 = a * $2^{n}$ |
| >> | right shift| a >> n = a * $2^{-n}$ |
{: rules="groups"}

비트 연산은 우선순위에 주의가 필요합니다. 일반적으로 사칙연산은 비교, 논리 연산자보다 우선 순위가 높습니다. 하지만 비트 연산은 논리 연산보다 우선순위가 높으나 비교 연산보다는 낮습니다. 아래 두 식은 동일한 수식입니다.

```cpp
if(x & y == 0)
if(x & (y==0))
```

<br>
### 비트 연산의 응용
* AND & : 비트 집합 두개를 AND하면 교집합
* OR  \| : 비트 집합 두개를 OR하면 합집합
* XOR ^ : True/False를 번갈아 바꾸는 스위치 구현과 같이 몇 개의 bit를 바꿔서 대응되는 수를 구할 수 있음(ASCII코드에서 짝이 맞는 문자끼리 다른 bit를 XOR시키는 기법을 이용한 대소문자 변환 함수 등..)
* NOT ~ : 비트 집합에 사용하면 가지고 있지 않은 원소들을 구할 수 있음
* SHIFT >> : 나누기 혹은 곱하기 연산을 대신해서 사용 가능(속도의 이점)
* i & (1 << j) : i 숫자의 j 번째 bit가 1인지 아닌지를 판별

<br>
### Bit Masking
각 Bit하나를 Flag로 활용한다면 자료 저장과 집합 표현을 쉽게 할 수 있습니다. \
0~31 사이의 번호가 매겨져 있고 사람 A의 친구 목록이 2의 배수이고, B의 친구 목록이 3의 배수라고 할 때, \
A, B 모두와 친구인 사람은? \
A 또는 B와 친구인 사람은? \
과 같은 집합 문제를 비트를 사용하면 쉽게 풀 수 있습니다.

A $\quad$
|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0| 
{: rules="groups"}

B $\quad$
|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0| 
{: rules="groups"}

A & B(A B 모두와 친구) $\quad$
|1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|1|0| 
{: rules="groups"}

A \| B(A 또는 B와 친구) $\quad$
|1|0|1|1|1|0|1|0|1|1|1|0|1|0|1|1|1|0|1|0|1|1|1|0|1|0|1|1|1|0|1|0|
{: rules="groups"}

<br>
### Data Compression
문자열 두 개를 비교할 때 O(문자열의 길이)의 시간이 드는데, 만약 사용하는 문자의 가지수가 적다면 필요한 bit만 골라내어 압축시킬 수 있습니다.

```cpp
long long compress(char str[10){
    long long res = 0;
    for(size_t i=0; i<12; ++i){
        res = (res<<5) | str[i] ^ 64);
    }
    return res;
}
```

<br>
### 실수
우리는 소수점 이하의 실수를 표현할 때 정확한 값을 계산하는 것이 아닌 근사 값을 활용합니다. 소수점 이하 4자리를 10진수로 나타내보면 2진수 0.1은 10진수 0.5 2진수 0.01은 10진수 0.25 2진수 0.001은 10진수 0.125로 2진수 0.0001은 10진수 0.0625로 표현이 됩니다. 이런 점을 사용해 우리는 floating-point 표기법을 사용합니다. 예를 들어, 314.625를 bits로 표현하면 100111010.101이 됩니다. 이 2진수의 소수점을 아래와 같이 왼쪽으로 이동시켜서 1.00111010101 * $2^{8}$로 표현할 수 있습니다. 이때 부호 1비트 \| 지수 8비트(숫자 8) \| 가수 23비트(100111010101)로 숫자를 표현할 수 있습니다. 추가적으로 지수 비트에는 음수 양수의 값이 들어갈 수 있기 때문에 맨 앞 부호비트 + 7비트로 -128~127까지 표현할 수 있습니다.
<img src="/assets/img/algorithm/Floating_Point.jpg" width="50%">


